현재는 프로젝트 뼈대만 남아있음. 새로운 메인 기능은 추가 예정

---

## 개발 회고: 소셜 로그인 구현 과정에서 얻은 교훈

이 프로젝트의 소셜 로그인 기능을 구현하면서, 특히 두 번째와 세 번째 연동 과정에서 여러 기술적 어려움을 겪었습니다. 이 경험을 통해 얻은 교훈을 다음 개발자가 참고할 수 있도록 기록합니다.

### 1. 가장 근본적인 원인: 각기 다른 OAuth 응답 구조

초기 구현이 어려웠던 가장 큰 이유는 각 소셜 플랫폼이 제공하는 사용자 정보의 JSON 구조가 모두 달랐기 때문입니다.

*   **구글 (Google - OIDC 표준):**
    *   **구조:** OpenID Connect(OIDC) 표준을 따르므로, 모든 정보가 최상위 레벨에 **평평하게(flat)** 존재합니다.
    *   **예시:** `sub`(ID), `email`, `name` 등을 바로 꺼내 쓸 수 있어 파싱이 가장 간단합니다.

*   **네이버 (Naver - 일반 OAuth 2.0):**
    *   **구조:** 모든 사용자 정보가 `response` 라는 **단일 객체 안에 중첩(fully nested)** 되어 있습니다.
    *   **예시:** 이메일을 얻으려면 `attributes.get("response").get("email")` 과 같이 두 단계를 거쳐야 합니다.

*   **카카오 (Kakao - 일반 OAuth 2.0):**
    *   **구조:** 네이버와 구글의 중간 형태로, **부분적으로 중첩(partially nested)** 되어 있습니다.
    *   **예시:** `id`는 최상위에 있지만, 이메일은 `kakao_account` 객체 안에, 닉네임은 `properties` 객체 안에 각각 나뉘어 들어있습니다.

초기 코드는 네이버의 구조에만 맞춰져 있었기 때문에, 다른 구조를 가진 구글과 카카오 연동 시 `NullPointerException`이 연쇄적으로 발생했습니다.

### 2. 아키텍처의 문제: 역할과 책임(R&R)의 모호함

위 문제를 해결하는 과정에서, 여러 클래스가 각자의 방식으로 데이터 파싱을 시도하며 책임이 모호해지는 문제가 발생했습니다. 이는 '두더지 잡기'처럼 한 곳의 버그를 수정하면 다른 곳에서 새로운 버그가 발생하는 악순환을 낳았습니다.

최종적으로 아래와 같이 각 클래스의 역할을 명확히 분리하는 아키텍처로 문제를 해결했습니다.

*   **`CustomOAuth2UserService` (데이터 정규화):**
    *   **역할:** 네이버나 카카오처럼 중첩된 응답을 받으면, 이를 **평평한 구조의 Map으로 '펴주는' 역할**만 책임집니다.
    *   **결과:** 이 클래스를 거치면, 모든 소셜 로그인의 사용자 정보가 구글(OIDC)과 유사한 단일 레벨의 Map 구조로 통일됩니다.

*   **`OAuthAttributes` (데이터 변환):**
    *   **역할:** 위에서 정규화된(펴진) Map 데이터를 받아, 우리 시스템의 `User` 엔티티로 **'변환'**하는 역할만 책임집니다.

*   **`OAuth2SuccessHandler` (비즈니스 로직 실행):**
    *   **역할:** `OAuthAttributes`로부터 `User` 객체를 받아 DB에 저장/업데이트하고, JWT를 발급하는 등 최종 **'비즈니스 로직'**을 실행합니다.

### 향후 개발 시 유의할 점 (핵심 교훈)

1.  **공식 문서 확인부터:** 새로운 외부 API를 연동할 때는, 가장 먼저 공식 문서를 통해 **응답 데이터의 정확한 구조를 확인**하는 습관이 중요합니다.
2.  **역할 분리 설계 (정규화 → 변환 → 실행):** 외부 데이터를 다룰 때는 **(1) 데이터를 가져와 일관된 형식으로 정규화하고, (2) 우리 시스템 모델로 변환한 뒤, (3) 비즈니스 로직을 실행**하는 단계를 명확히 분리하여 설계하면, 유지보수가 쉽고 안정적인 코드를 작성할 수 있습니다.
